# .gitlab-ci.yml

# No default image defined at the top level,
# as the runner itself is expected to have Docker for the build step.
# If you need an image for other stages (like deploy), define it per job.

# Define stages of the pipeline
stages:
  - build
  - deploy

# Define variables for the container image
variables:
  # This image name will essentially be just project_path/repository_name.
  # When pushed without an explicit tag, Docker defaults to 'latest'.
  # Alternatively, you could use $CI_COMMIT_SHORT_SHA for a unique, untagged image ID.
  CONTAINER_REPOSITORY: $CI_REGISTRY/$CI_PROJECT_PATH

# --- Build Stage ---
build_image:
  stage: build
  # No 'image' or 'services' here, assuming runner has Docker installed.
  # The 'tags' keyword here is for the runner, not the Docker image.
  # Ensure your runner is registered with a tag like 'docker-host' or 'self-hosted'
  # if you have specific runners configured for this.
  tags:
    - shell-executor # Example tag for a runner configured with shell executor and Docker access.
                     # Or a specific tag you assigned to your self-hosted Docker-enabled runner.
  script:
    - echo "Logging into GitLab Container Registry..."
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - echo "Building Docker image: $CONTAINER_REPOSITORY"
    # Build without explicitly specifying a tag. Docker often defaults to 'latest'.
    # Or, if you want a simple unique identifier without a 'tag' keyword:
    # - docker build -t $CONTAINCONTAINER_REPOSITORY:$CI_COMMIT_SHORT_SHA .
    # - docker push $CONTAINER_REPOSITORY:$CI_COMMIT_SHORT_SHA
    - docker build -t $CONTAINER_REPOSITORY .
    - echo "Pushing Docker image to registry..."
    - docker push $CONTAINER_REPOSITORY
    - echo "Image built and pushed successfully."
  only:
    - main
    - master
    - tags # You can keep this for triggering builds on tags if desired

# --- Deploy Stage ---
deploy_production:
  stage: deploy
  image: alpine/git # Use a specific image for deployment if your runner doesn't have SSH tools
  tags:
    - shell-executor # Use the same runner tag as your build job, or a dedicated deploy runner
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $SSH_HOST > ~/.ssh/known_hosts
    - chmod 600 ~/.ssh/known_hosts
  script:
    - echo "Deploying application to $SSH_HOST..."
    # SSH into your server and pull/run the latest Docker image
    # Note: We're pulling $CONTAINER_REPOSITORY which, when pushed without a tag, defaults to ':latest'
    - ssh $SSH_USER@$SSH_HOST "
        docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY &&
        docker pull $CONTAINER_REPOSITORY && # Pulls the default tagged image (e.g., 'latest')
        docker stop my-rag-app || true &&
        docker rm my-rag-app || true &&
        docker run -d --name my-rag-app -p 80:5000 \
        -e MONGO_URI=\"$MONGO_URI\" \
        -e GEMINI_API_KEY=\"$GEMINI_API_KEY\" \
        -e DB_NAME=\"$DB_NAME\" \
        -e COLLECTION_NAME=\"$COLLECTION_NAME\" \
        -e VECTOR_SEARCH_INDEX_NAME=\"$VECTOR_SEARCH_INDEX_NAME\" \
        $CONTAINER_REPOSITORY" # No explicit tag needed, Docker resolves to 'latest'
    - echo "Deployment complete!"
  only:
    - main
    - master
  environment: production